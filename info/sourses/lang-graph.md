статья - https://habr.com/ru/companies/amvera/articles/933460/

## Передача инструментов агенту

### Концепция работы

Языковая модель (агент) не может напрямую выполнять действия в браузере или системе. Вместо этого ей предоставляются **инструменты** - функции Python, которые модель может вызывать.

**Как это работает:**

1. **Разработчик** определяет набор инструментов (например, "открыть страницу", "нажать кнопку")
2. **Система** передаёт модели описание каждого инструмента: что он делает и какие входные данные принимает
3. **Модель** анализирует задачу пользователя и решает, какой инструмент вызвать
4. **Модель** генерирует вызов инструмента с конкретными значениями входных данных
5. **Система** выполняет функцию и возвращает результат модели
6. **Модель** использует результат для следующего шага или формирует ответ пользователю

**Ключевая проблема:** Модель должна точно знать, какие входные данные ожидает каждый инструмент. Для этого используются **схемы** - строгие описания структуры данных в формате, понятном модели.

### Зачем нужны явные схемы

Без явного описания структуры входных данных система пытается автоматически определить их из кода функции. Это часто приводит к ошибкам:
- Модель генерирует вызов в неправильном формате
- API отклоняет запрос с ошибкой
- Агент не может выполнить задачу

**Решение:** Использовать библиотеку проверки данных (Pydantic) для создания строгих описаний входных данных каждого инструмента.

## Описание инструментов для агента

### Формат определения инструмента

Каждый инструмент состоит из трёх компонентов:

1. **Схема входных данных** - описание структуры данных, которые принимает функция
2. **Функция-исполнитель** - код, который выполняет действие
3. **Обёртка инструмента** - связывает схему с функцией для передачи модели

```python
from pydantic import BaseModel, Field
from langchain_core.tools import StructuredTool

# 1. Схема входных данных
class ToolInput(BaseModel):
    """Строка документации - объясняет назначение инструмента"""
    param1: str = Field(description="Текстовое пояснение для модели")
    param2: int = Field(default=10, description="Входной параметр с начальным значением")

# 2. Функция-исполнитель (определена отдельно)
async def my_tool_function(param1: str, param2: int) -> str:
    # Код выполнения действия
    return f"Результат: {param1}, {param2}"

# 3. Обёртка инструмента
tool = StructuredTool.from_function(
    coroutine=my_tool_function,    # Ссылка на асинхронную функцию (или func= для обычной)
    name="tool_name",              # Имя, по которому модель вызывает инструмент
    description="Что делает инструмент",  # Текстовое объяснение для модели
    args_schema=ToolInput          # Схема входных данных (ОБЯЗАТЕЛЬНО!)
)
```

**Важно:** Параметр `args_schema` обязателен. Без него модель не сможет правильно сформировать вызов инструмента.

### Поля обёртки инструмента

| Поле | Тип | Назначение |
|------|-----|------------|
| `name` | строка | Имя инструмента. Модель использует это имя для вызова. Должно быть уникальным и понятным. |
| `description` | строка | Текстовое объяснение назначения инструмента. Модель читает это, чтобы понять, когда использовать инструмент. Чем подробнее, тем точнее выбор модели. |
| `args_schema` | класс | Схема входных данных (класс из библиотеки проверки данных). Определяет, какие входные параметры принимает функция, их типы и ограничения. |
| `coroutine` | функция | Ссылка на асинхронную функцию-исполнителя. Используется для операций ввода-вывода (сеть, диск, браузер). |
| `func` | функция | Ссылка на обычную (синхронную) функцию. Используется для простых вычислений. Либо `coroutine`, либо `func` - что-то одно. |

### Поля схемы входных данных

Схема определяет, какие входные параметры принимает инструмент. Каждое поле схемы описывает один входной параметр.

```python
from typing import Literal, Union

class ExampleInput(BaseModel):
    # Обязательный входной параметр (без начального значения)
    required_param: str = Field(description="Текстовое пояснение для модели")
    
    # Входной параметр с начальным значением (можно не указывать при вызове)
    optional_param: int = Field(default=100, description="Целое число с начальным значением")
    
    # Входной параметр с ограниченным набором значений
    direction: Literal["up", "down", "left", "right"] = Field(
        description="Направление движения. Только одно из четырёх значений"
    )
    
    # Входной параметр, принимающий разные типы данных
    value: Union[str, int] = Field(description="Текст или число")
```

**Настройки описания поля (Field):**

| Параметр | Назначение | Пример |
|----------|-----------|--------|
| `description` | Текстовое пояснение для модели. Модель читает это, чтобы понять, что вводить. **Обязательно!** | `"URL адрес страницы"` |
| `default` | Начальное значение. Если модель не укажет этот параметр, используется это значение. | `default=10` |
| `ge`, `le` | Ограничение диапазона для чисел (больше-или-равно, меньше-или-равно) | `ge=0, le=100` |
| `min_length`, `max_length` | Ограничение длины для текста | `min_length=1, max_length=500` |
| `regex` | Шаблон проверки текста | `regex=r"^https?://"` |

**Типы входных параметров:**

- `str` - текстовая строка
- `int` - целое число
- `float` - дробное число
- `bool` - логическое значение (True/False)
- `Literal["a", "b"]` - только указанные значения
- `Union[str, int]` - один из указанных типов
- `List[str]` - список значений
- `Dict[str, Any]` - словарь данных

### Инструменты без параметров

```python
class NoArgsInput(BaseModel):
    pass

tool = StructuredTool.from_function(
    coroutine=func,
    name="get_info",
    description="...",
    args_schema=NoArgsInput
)
```

### Преобразование схемы для модели

Система автоматически преобразует схему входных данных в специальный формат описания данных (JSON Schema), понятный языковой модели:

**Схема в коде Python:**
```python
class NavigateInput(BaseModel):
    url: str = Field(description="URL адрес страницы")
```

**Преобразуется в формат для модели:**
```json
{
  "type": "function",
  "function": {
    "name": "navigate",
    "description": "Открыть веб-страницу по адресу",
    "parameters": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string",
          "description": "URL адрес страницы"
        }
      },
      "required": ["url"]
    }
  }
}
```

Модель видит это описание и понимает:
- Есть инструмент с именем `navigate`
- Он принимает один обязательный входной параметр `url` типа текст
- Параметр должен содержать адрес страницы

На основе этого описания модель генерирует правильный вызов инструмента.

### Передача инструментов модели

После создания всех инструментов их нужно передать языковой модели. Это делается через метод связывания:

```python
from langchain_groq import ChatGroq

# 1. Создать экземпляр языковой модели
model = ChatGroq(
    model="llama-3.3-70b-versatile",
    api_key="ваш_ключ_доступа"
)

# 2. Собрать все инструменты в список
tools = [navigate_tool, click_tool, type_tool]

# 3. Связать инструменты с моделью
model_with_tools = model.bind_tools(tools)

# 4. Теперь модель может вызывать инструменты при ответе на запросы
response = await model_with_tools.ainvoke(messages)
```

**Что происходит при связывании:**

1. Система извлекает схемы всех инструментов
2. Преобразует схемы в формат описания данных для модели
3. Отправляет описания модели вместе с запросом пользователя
4. Модель видит доступные инструменты и может решить их вызвать
5. При вызове модель генерирует данные согласно схеме
6. Система проверяет данные по схеме и выполняет функцию

**Цикл работы агента с инструментами:**

```
Пользователь → Запрос
    ↓
Модель → Анализ + Решение вызвать инструмент
    ↓
Система → Проверка данных по схеме
    ↓
Функция → Выполнение действия
    ↓
Система → Возврат результата модели
    ↓
Модель → Анализ результата + Следующий шаг или Ответ
    ↓
Пользователь ← Результат
```

Схемы обеспечивают корректность данных на каждом шаге этого цикла.

